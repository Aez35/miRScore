#!/usr/bin/env python3.6

# miRScore is a miRNA scoring tool. 
# Its function is to determine if previously annotated miRNA candidates are of high confidence.
# It does by analyzing the sequences of the candidate miRNA and it's hairpin precursor.
# Fastq files containing reads of the proposed miRNAs must be provided as evidence.
# The first step is to quantify reads of each candidate miRNA and ensure it is present in at least 2 libraries.
# Next, the structure of the candidate miRNA is scored accordingly to criteria in Axtell and Meyers (2018).
# The output file contains a list of successful candidates, their scores, and details about each successful candidate.
# Additional outputs include the failed miRNAs and the step in which they failed.

import RNA
import pandas as pd
import pysam
from pysam import FastaFile
import argparse
import subprocess
from Bio import SeqIO
import os
import glob
from pathlib import Path
import csv
import regex
import sys
import time

#Assign arguments for command line
ap = argparse.ArgumentParser()

ap.add_argument("--fastq", help="Directory containing fastq files")
ap.add_argument("--bamfile", help="Directory containing bamfiles")
ap.add_argument("--mature", required = True, help="fasta file of mature miRNA sequence")
ap.add_argument("--hairpin", required = True, help="fasta file of precursor sequence")
ap.add_argument("--mm", help="Allow up to 1 mismatch in miRNA reads")

args = ap.parse_args()



### ____________________ Functions ______________________ ###

def get_s_rels(q_rel_start, q_rel_stop, dotbracket):
# Compute position of miR* given miR location on a dotbracket
    # Get a lookup table of paired positions
    pairs = get_pairs(dotbracket)
 
    # determine the 3' end (stop) of miR* from q_rel_start
    s_rel_stop = None
    for attempts, qpos in enumerate(range(q_rel_start, q_rel_stop)):
        if pairs[qpos] is not None:
            s_rel_stop = pairs[qpos] + attempts + 2
            break
   
    # determine the 5' end (start) or miR* from q_rel_stop - 2
    s_rel_start = None
    for attempts, qpos in enumerate(range((q_rel_stop - 2), q_rel_start, -1)):
        if pairs[qpos] is not None:
            s_rel_start = pairs[qpos] - attempts
            break
   
    return s_rel_start, s_rel_stop
   

def get_pairs(dotbracket):
# Compute positional lookups for a dotbracket structure
# Note conversion from enumerate's zero-based system to one-based
    pairs = {}
    for i, j in enumerate(dotbracket):
        pairs[(i + 1)] = None
   
    stack = []
    for i, j in enumerate(dotbracket):
        if j == '(':
            stack.append((i + 1))
        elif j == ')':
            bp1 = stack.pop()
            bp2 = i + 1
            pairs[bp1] = bp2
            pairs[bp2] = bp1
    return pairs
 

def score(mir,seq,mirsspos,mirpos,ss):
#Determine score of candidate miRNA based on criteria outlined in Axtell and Meyers et al 2018.
    reason=[]
    mscore = []
    # Test that precursor is less than 300 nt
    if len(seq)>300:
        mscore.append(5)
        reason.append("Precursor > 300 nt")
    else:
        mscore.append(10)
        
    #Test length of miRNA
    if (len(mir)>24) or (len(mir)<20):
        mscore.append(0)
        reason.append("miRNA > 24 or < 20")
    elif (len(mir)>19) and (len(mir)<23):
        mscore.append(10)
    elif (len(mir)>22) and (len(mir)<25):
        mscore.append(5)
        reason.append("23/24 nt miRNA")

    #Obtain dotbrackets of mir and mirstar
    mirstar_db=ss[mirsspos[0]:mirsspos[1]]
    mir_db = ss[mirpos[0]:mirpos[1]]

    #Test that mir/mir* duplex does not contain greater than 5 mismatches
    if (mirstar_db.count(".")>5) or (mir_db.count(".") > 5):
        mscore.append(5)
        reason.append("more than 5 mismatches")
    else:
        mscore.append(10)
    #Test that mir/miR* does not contain an asymmetric bulge greater than 3    
    if index_of("....", mirstar) == -1 and index_of("...", mir) != -1:
        mscore.append(5)
        reason.append("asymmetric bulge greater than 3")
    elif index_of("....", mirstar) != -1 and index_of("...", mir) == -1:
        mscore.append(5)
        reason.append("asymmetric bulge greater than 3")
    else:
        mscore.append(10)
    return mscore, reason


def index_of(asym, in_list):
#Determine asymmetry in mir complex
    try:
        return in_list.index(asym)
    except ValueError:
        return -1

def is_fasta(filename):
#Determine if file is a fasta file
    with open(filename, "r") as handle:
        fasta = SeqIO.parse(handle, "fasta")
        return any(fasta)  # False when `fasta` is empty, i.e. wasn't a FASTA file

def check_fastas(args):
#Check that hairpin and miRNA files are FASTA files
    if is_fasta(args.hairpin) == False:
        sys.exit("Error: Hairpin file must be in fasta format.")
    if is_fasta(args.mature) == False:
        sys.exit("Error: Mature sequence must be in fasta format.")

def find_indices_of(char, in_string):
#Find index of miRNA in hairpin
    index = -1
    while True:
        index = in_string.find(char, index + 1)
        if index == -1:
            break
        yield index

def run(cmd) :
#Run command for samtools
    proc = subprocess.call(cmd, shell=True, stdout=subprocess.PIPE)

def align_fastqs(args, fastqs):
#Build index and map hairpins to fastq files
    print("Building index...")
    #Create index of hairpins using bowtie
    subprocess.call(['bowtie-build', args.hairpin, 'hairpin'])

    print("Mapping each fastq file to hairpin...")
    for file in fastqs:
    #Map each fastq file in directory to index.
        print("Mapping " + file + "...")
        subprocess.call(['bowtie', "-a", 'hairpin', file , "-S", "alignments/" + Path(file).stem + ".bam"])

def DNAcheck(dna):
#Check that all characters in provided sequences are ATGCU
    y = dna.upper()
    if regex.match("^[ATGCU]+$", y):
        return(2)
    else:
        return(1)
### _______________________ Code begins __________________________ ###


# Read in candidate miRNA hairpin and precursor
mir_fa = FastaFile(args.mature)
hairpin_fa = FastaFile(args.hairpin)
check_fastas(args)

#Fetch miRNA precursor sequence matching mature candidate miRNA sequence
mir_dict =  SeqIO.index(args.mature, "fasta")
hp_dict = SeqIO.index(args.hairpin, "fasta")

#***********  Check for miRNA Reads  *****************
#Initialize dictionary of failed miRNAs and successful candidate miRNAs.
## These dictionaries will be used to generate the final output of the program:

#Working list of miRNAs that failed and the first criteria in which they failed.
failed = {}
mirnas = {}
rev_mir={}
mir_one={}
subprocess.call(["mkdir","RNAplots"])

#Check that each miRNA contains only A, T, G, C. If not, add to failed or quit.
print("Checking hairpin and miRNA sequences...")
for mir in mir_dict:
    if mir in hp_dict:
        characters = str(mir_dict[mir].seq)
        result = DNAcheck(characters)
        if result == 1:
            failed[mir]="Sequence contained characters besides A, T, G, or C"
        else:
            characters_hp = str(hp_dict[mir].seq)
            result2 = DNAcheck(characters_hp)
            if result2 == 1:
                failed[mir]="Hairpin contained characters besides U, A, T, G, or C"
            else:
                mir_one[mir]=mir_dict[mir].seq
    else:
        failed[mir] = "Candidate miRNA does not have a hairpin of the same name"


# Check that miRNA does not multimap to hp.
# Now add sequence with any mismatch to revised miRNAs {rev_mir}.
print("Checking hairpin length and multimapping...")
for name in mir_one:
    if name in hp_dict:
        hp=hp_dict[name].seq
        mir=mir_dict[name].seq
        if (len(hp)<50):
            failed[name] = "Hairpin is less than 50 basepairs"
        else:
            if hp.count(mir)>1:
                failed[name] = "miRNA multimaps to hairpin" 
            else:
                rev_mir[name]=mir_dict[name].seq 

#Created bam files mapped to hairpin sequences.
if len(rev_mir)>0:
    if args.fastq is not None:

        ##Create a list of all fastq files in provided directory.
        fastqs=glob.glob(args.fastq + '/*.fastq')
        if len(fastqs)<2:
            sys.exit("Error: miRScore requires at least two fastq files.")
        #Make output directory.
        subprocess.call(["mkdir","alignments"])

        align_fastqs(args,fastqs)

    elif args.bamfile is not None:
        print("Converting bams to fastq for mapping to hairpin...")
        bams2convert=glob.glob(args.bamfile + "/*.bam")
        if len(bams2convert)<2:
            sys.exit("Error: miRScore requires at least two libraries.")
        for file in bams2convert:
            cmd = "samtools bam2fq " + file + ' >' + Path(file).stem + ".fastq"
            run(cmd)
        fastqs=glob.glob(args.bamfile + '/*.fastq')
        subprocess.call(["mkdir","alignments"])
        align_fastqs(args,fastqs)

    #Create list of bam files from bowtie output.
    bamfiles=glob.glob('alignments/*.bam')

    #Sort each bamfile and create a dictionary of read counts for each miRNA
    mircounts = {}
    for bam in bamfiles:
        print("Beginning next bam file...")
        #Sort bam files
        pysam.sort("-o", "alignments/" + Path(bam).stem + "_sorted.bam", bam)
        pysam.index("alignments/" + Path(bam).stem + "_sorted.bam")

        #Read in bamfile in pysam format
        bamfile = pysam.AlignmentFile("alignments/" + Path(bam).stem + "_sorted.bam", "rb")

        #Count the number of reads each miRNA (x) appears in bamfile
        mir_counts={}
        save_mir_counts={}
        for mirName in rev_mir:
            #Get loci of miRNA
            mir=str(rev_mir[mirName])
            hp=str(hp_dict[mirName].seq)

            indices=[]
            reads=[]
            for i in find_indices_of(mir, hp):
                indices.append(i)
            if len(indices)==1:
                # Allow 1-2 positional variance in miRNA reads
                if hp.index(mir)!= 0:
                    mstart=hp.index(mir) - 1
                    mstop=mstart+len(mir) + 1
                else:
                    mstart=hp.index(mir)
                    mstop=mstart+len(mir) + 1

                #Count reads of miRNA in bamfile
                for read in bamfile.fetch(mirName,mstart,mstop):
                    reads.append(read.seq)
                if reads.count(mir) > 0:
                    if mircounts.get(mirName)== None:
                        #If not in {mircounts}, add it.
                        #print(x + " not yet in mircounts")
                        mircounts[mirName]= 1
                    else:
                        mircounts[mirName] = mircounts[mirName] + 1
                else:
                    if mircounts.get(mirName) == None:
                        mircounts[mirName] = 0
                print(mirName + " reads: " + str(reads.count(mir)))
                save_mir_counts[mirName]=reads.count(mir)
                reads.clear()
            else:
                if failed.get(mirName) == None:
                    failed[mirName] = "miRNA not found in hairpin"

    #If at least one read of the miRNA (x) is found, add it to {mirnas}. Otherwise add it to {failed}.
    for x in mircounts:
        if mircounts[x] > 1:
            mirnas[x] = rev_mir[x]
        else:
            failed[x] = "Not present in more than one library" 

    print(str(len(mirnas)) + " potential miRNAs found.")
    print(str(len(failed)) + " miRNAs have failed.")

    #***********  STEP 3: Count miR*, score miR/miR*/hairpin, and write output file  *****************
    #File save
    header=["miRNA","miRScore","Precursor Length","mir sequence", "miRNA length","mir reads","mir* sequence","miR* Length","mir* reads", "Reasons for failing"]
    with open('novel_miRNAs.csv', mode='w', newline='') as csv_file:
        csv_writer = csv.writer(csv_file)

        save_mirs_counts={}
        data=[]
        mirstar_counts={}

        #retrieve mature sequence for each miRNA in {mirnas} and produce RNAfold structure.
        for key in mirnas:
            print(key)
            #Hairpin sequence
            seq = str(hp_dict[key].seq)
            #mature sequence
            mat = rev_mir[key]
            #Vienna RNA Fold 
            (ss, mfe)=RNA.fold(seq)

            #Index mir while allowing 1 nt mismatch
            m=regex.findall(str(mat) + '{s<=1}', str(seq)) # s<=1 allows 1 mismatch

            #Find start and stop of miR
            mstart_int=seq.index(m[0])
            mstop=mstart_int+len(mat)
            mstart=mstart_int+1

            #Locate start and stop of miR/miR*
            mirpos=[mstart,mstop]
            mirspos=get_s_rels(mstart,mstop,ss)
            #Python indexing of mir position
            mirsspos=[(mirspos[0]-1),(mirspos[1])]
            print(mirsspos)
            
            #Count if miR* reads are present in bamfiles.
            reads_mirs=[]


            if mirsspos[0] > mirsspos[1]:
                failed[key]="miR* is not detectable"
            else:
                #Get loci of miRNA
                hp=hp_dict[key].seq
                mirstar=hp[mirsspos[0]:mirsspos[1]]
                print(mirstar)

                #Count miR* reads in bamfiles
                bamfiles=glob.glob("alignments/*sorted.bam")
                for bam in bamfiles:
                    bamfile = pysam.AlignmentFile(bam, "rb")
                    for read in bamfile.fetch(key,mirsspos[0],mirsspos[1]):
                        reads_mirs.append(read.seq)
                    if reads_mirs.count(mirstar) > 0:
                        if mirstar_counts.get(key)== None:
                        #If not in {mircounts}, add it.
                            print(key + " not yet in mircounts")
                            mirstar_counts[key]= 1
                        else:
                            mirstar_counts[key] = mirstar_counts[key] + 1
                    else:
                        if mirstar_counts.get(key)== None:
                            mirstar_counts[key]= 0
                    print("mir* reads: " + str(reads_mirs.count(mirstar)))
                    save_mirs_counts[key]=reads_mirs.count(mirstar)

                    reads.clear()
                #If counts detected for miR*, score miRNA and save results.
                if mirstar_counts[key]!= None:
                    if mirstar_counts[key] > 1:
                            print("Scoring miRNA "+ key)
                            result = score(mat,seq,mirsspos,mirpos,ss)
                            #print(result[1])
                            print(result[0])
                            if len(result[1])>0:
                                save=[key,result[0],len(seq),str(mat).translate(str.maketrans("tT", "uU")),len(mat),str(save_mir_counts[key]),str(mirstar).translate(str.maketrans("tT", "uU")),len(mirstar),str(save_mirs_counts[key]), result[1]]
                            else:
                                save=[key,result[0],len(seq),str(mat).translate(str.maketrans("tT", "uU")),len(mat),str(save_mir_counts[key]),str(mirstar).translate(str.maketrans("tT", "uU")),len(mirstar),str(save_mirs_counts[key])]
                            data.append(save)

                            #Create ps file from RNAplot
                            os.chdir('RNAplots')
                            f= open(key+".fa", "a")
                            f.write("> " + str(key) + '\n' + str(hp))
                            f.close()
                            command=("RNAfold " + key+ ".fa | RNAplot --pre '" + str(mstart)+ " " + str(mstop) + " 8 GREEN omark " + str(mirspos[0]) + " " + str(mirspos[1]) + " 8 RED omark'")
                            print(command)
                            subprocess.Popen(command, shell=True)
                            subprocess.call(["rm","*.fa"])
                            os.chdir('..')
                    else:
                        failed[key]="miR* reads not present"

        csv_writer.writerow(header)
        for row in data:
            csv_writer.writerow(row)

    #Remove excess bam files and indexes.
    args =  ('rm', '-rf', 'alignments/*sorted*')
    subprocess.call('%s %s %s' % args, shell=True)
    args = ('rm', '-rf', '*ebwt')
    subprocess.call('%s %s %s' % args, shell=True)

#Write failed output file for any failed miRNAs.
faildata=[]
failheader=["miRNA", "Reason for failing"]

with open('failed_miRNAs.csv', mode='w', newline='') as csv_file:
    csv_writer = csv.writer(csv_file)
    csv_writer.writerow(failheader)
    for fail in failed:
        failsave=[fail, failed[fail]]
        faildata.append(failsave)
    for rows in faildata:
        csv_writer.writerow(rows)

#Remove alignments directory.
#subprocess.call(["rm","-r","alignments"])

try:
    data
except NameError:
    var_exists = False
else:
    var_exists = True

if var_exists == True:
    print("Summary")
    print("____________________________________")
    print("Number of submitted candidate miRNAs: " + str(len(mir_dict)))
    print("Total number of miRNAs identified with high confidence: " + str(len(data)) )
    print("Total number of Failed miRNAs: " + str(len(failed)))
    print('')
    print(time.strftime("%a %d %b %Y %H:%M:%S %z %Z", time.localtime()))
    print('Run Completed!')
else:
    print("Failed to run")

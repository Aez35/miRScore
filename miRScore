#!/usr/bin/env python

# miRScore is a miRNA scoring tool. 
# Its function is to determine if previously annotated miRNA candidates are of high confidence.
# It does by analyzing the sequences of the candidate miRNA and it's hairpin precursor.
# Fastq files containing reads of the proposed miRNAs must be provided as evidence.
# The first step is to quantify reads of each candidate miRNA and ensure it is present in at least 2 libraries.
# Next, the structure of the candidate miRNA is scored accordingly to criteria in Axtell and Meyers (2018).
# The output file contains a list of successful candidates, their scores, and details about each successful candidate.
# Additional outputs include the failed miRNAs and the step in which they failed.

import RNA
import pandas as pd
import re
import pysam
from pysam import FastaFile
import argparse
import shutil
import subprocess
from subprocess import Popen, PIPE, STDOUT
from Bio import SeqIO
import os
import tqdm
import glob
from pathlib import Path
import csv
import sys
import time
startTime = time.time()


print("Checking required packages...")
req_packs=["bowtie","samtools","RNAfold"]

for pack in req_packs:
        path = shutil.which(pack)
        if path is not None:
            print('Requires package {0} : {1}'.format(pack,path))
        else:
            msg = 'Requires package {0} : Not found!'.format(pack)
            sys.exit(msg)



#Assign arguments for command line
ap = argparse.ArgumentParser()

ap.add_argument("--fastq", help="Directory containing fastq files")
ap.add_argument("--bamfile", help="Directory containing bamfiles")
ap.add_argument("--mirnas", required = True, help="fasta file of mature miRNA sequence")
ap.add_argument("--precursors", required = True, help="fasta file of precursor sequence")
ap.add_argument("--mm", help="Allow up to 1 mismatch in miRNA reads",metavar='')

args = ap.parse_args()



### ____________________ Functions ______________________ ###

def get_s_rels(q_rel_start, q_rel_stop, dotbracket):
# Compute position of miR* given miR location on a dotbracket
    # Get a lookup table of paired positions
    pairs = get_pairs(dotbracket)
 
    # determine the 3' end (stop) of miR* from q_rel_start
    s_rel_stop = None
    for attempts, qpos in enumerate(range(q_rel_start, q_rel_stop)):
        if pairs[qpos] is not None:
            s_rel_stop = pairs[qpos] + attempts + 2
            break
   
    # determine the 5' end (start) or miR* from q_rel_stop - 2
    s_rel_start = None
    for attempts, qpos in enumerate(range((q_rel_stop - 2), q_rel_start, -1)):
        if pairs[qpos] is not None:
            s_rel_start = pairs[qpos] - attempts
            break
   
    return s_rel_start, s_rel_stop
   

def get_pairs(dotbracket):
# Compute positional lookups for a dotbracket structure
# Note conversion from enumerate's zero-based system to one-based
    pairs = {}
    for i, j in enumerate(dotbracket):
        pairs[(i + 1)] = None
   
    stack = []
    for i, j in enumerate(dotbracket):
        if j == '(':
            stack.append((i + 1))
        elif j == ')':
            bp1 = stack.pop()
            bp2 = i + 1
            pairs[bp1] = bp2
            pairs[bp2] = bp1
    return pairs
 

def score(mir,seq,mirsspos,mirpos,ss):
#Determine score of candidate miRNA based on criteria outlined in Axtell and Meyers et al 2018.
    reason=[]
    mscore = []
    criteria=[]
    # Test that precursor is less than 300 nt
    if len(seq)>300:
        mscore.append(10)
        reason.append("Precursor > 300 nt")
        criteria.append("N")
    else:
        mscore.append(25)
        criteria.append("Y")
        
    #Test length of miRNA
    if (len(mir)>24) or (len(mir)<20):
        mscore.append(0)
        reason.append("miRNA > 24 or < 20")
        criteria.append("N")
    elif (len(mir)>19) and (len(mir)<23):
        mscore.append(25)
        criteria.append("Y")
    elif (len(mir)>22) and (len(mir)<25):
        mscore.append(25)
        reason.append("23/24 nt miRNA")
        criteria.append("23/24")

    #Obtain dotbrackets of mir and mirstar
    mirstar_db=ss[mirsspos[0]:mirsspos[1]]
    mir_db = ss[mirpos[0]:mirpos[1]]

    #Test that mir/mir* duplex does not contain greater than 5 mismatches
    if (mirstar_db.count(".")>5) or (mir_db.count(".") > 5):
        mscore.append(0)
        reason.append("more than 5 mismatches")
        if (mirstar_db.count("."))>(mir_db.count(".")):
            criteria.append(mirstar_db.count("."))
        else:
            criteria.append(mir_db.count("."))

    else:
        mscore.append(25)
        criteria.append(mir_db.count("."))


    #Test that mir/miR* does not contain an asymmetric bulge greater than 3    
    if index_of("....", mirstar_db) == -1 and index_of("....", mir_db) != -1:
        mscore.append(10)
        reason.append("asymmetric bulge greater than 3")
        criteria.append("1")
    elif index_of("....", mirstar_db) != -1 and index_of("....", mir_db) == -1:
        mscore.append(10)
        reason.append("asymmetric bulge greater than 3")
        criteria.append("1")
    else:
        mscore.append(25)
        criteria.append("0")

    return mscore, reason, criteria


def index_of(asym, in_list):
#Determine asymmetry in mir complex
    try:
        return in_list.index(asym)
    except ValueError:
        return -1

def is_fasta(filename):
#Determine if file is a fasta file
    with open(filename, "r") as handle:
        fasta = SeqIO.parse(handle, "fasta")
        return any(fasta)  # False when `fasta` is empty, i.e. wasn't a FASTA file

def check_fastas(args):
#Check that hairpin and miRNA files are FASTA files
    if is_fasta(args.precursors) == False:
        sys.exit("Error: Hairpin file must be in fasta format.")
    if is_fasta(args.mirnas) == False:
        sys.exit("Error: Mature sequence must be in fasta format.")

def find_indices_of(char, in_string):
#Find index of miRNA in hairpin
    index = -1
    while True:
        index = in_string.find(char, index + 1)
        if index == -1:
            break
        yield index

def run(cmd) :
#Run command for samtools
    proc = subprocess.call(cmd, shell=True, stdout=subprocess.PIPE)

def align_fastqs(args, fastqs):
    FNULL = open(os.devnull, 'w')

#Build index and map hairpins to fastq files
    print("Building index...")
    #Create index of hairpins using bowtie
    subprocess.call(['bowtie-build', args.precursors, 'hairpin'],stdout=FNULL,stderr=subprocess.STDOUT)

    #Map reads to hairpin
    print("Mapping each fastq file to hairpin...")
    for file in fastqs:
        if args.mm != None:
            print("Mapping with one mismatch...")
            subprocess.call(['bowtie', "-a","-v1","--no-unal", '-x','hairpin', file , "-S", "alignments/" + Path(file).stem + ".bam"],stdout=FNULL,stderr=subprocess.STDOUT)
        else:
            subprocess.call(['bowtie', "-a","-v0","--no-unal", 'hairpin', file , "-S", "alignments/" + Path(file).stem + ".bam"],stdout=FNULL,stderr=subprocess.STDOUT)

def DNAcheck(dna):
#Check that all characters in provided sequences are ATGCU
    y = dna.upper()
    if re.match("^[ATGCU]+$", y):
        return(2)
    else:
        return(1)
    
def add_values_in_dict(dict, key, list_of_values):
    if key not in dict:
        dict[key] = list()
    dict[key].extend(list_of_values)
    return dict
### _______________________ Code begins __________________________ ###

path="alignments"
isExist = os.path.exists(path)
if isExist==True:
    subprocess.call(["rm","-rf","alignments/"])
    print("Removed previous alignments folder.")

path="RNAplots"
isExist = os.path.exists(path)
if isExist==True:
    subprocess.call(["rm","-rf","RNAplots/"])
    print("Removed previous RNAplots folder.")

if args.bamfile != None:
    path=args.bamfile
    isExist = os.path.exists(path)
    if isExist!=True:
        msg="Direcory containing BAM files cannot be found."
        sys.exit(msg)
else:
    path=args.fastq
    isExist = os.path.exists(path)
    if isExist!=True:
        msg="Direcory containing FASTQ files cannot be found."
        sys.exit(msg)

# Read in candidate miRNA hairpin and precursor
mir_fa = FastaFile(args.mirnas)
hairpin_fa = FastaFile(args.precursors)
check_fastas(args)

#Fetch miRNA precursor sequence matching mature candidate miRNA sequence
mir_dict =  SeqIO.index(args.mirnas, "fasta")
hp_dict = SeqIO.index(args.precursors, "fasta")

#***********  Check for miRNA Reads  *****************
#Initialize dictionary of failed miRNAs and successful candidate miRNAs.
## These dictionaries will be used to generate the final output of the program:

#Working list of miRNAs that failed and the first criteria in which they failed.
mir_one={}
mirna_dict={}
failed={}

#Check that each miRNA contains only A, T, G, C. If not, add to failed or quit.
print("Checking hairpin and miRNA sequences...")
for mir in tqdm.tqdm(mir_dict,desc="Checking miRNAs"):
    if mir in hp_dict:
        characters = str(mir_dict[mir].seq)
        result = DNAcheck(characters)
        if result == 1:
            failed[mir]="Sequence contained characters besides A, T, G, or C"
        else:
            characters_hp = str(hp_dict[mir].seq)
            result2 = DNAcheck(characters_hp)
            if result2 == 1:
                failed[mir]="Hairpin contained characters besides U, A, T, G, or C"
            else:
                mir_one[mir]=mir_dict[mir].seq
    else:
        failed[mir] = "Candidate miRNA does not have a hairpin of the same name"

#Determine miRNA/miRNA* duplex and score structure for length, bulges, and mismatches.
for x in tqdm.tqdm(mir_one,desc="Scoring miRNAs):
    sleep(0.01)
    hp=str(hp_dict[x].seq)
    mir=str(mir_one[x])
    
    if mir in hp:
        # Allow 1-2 positional variance in miRNA position
        mstart=hp.index(mir)
        mstop=(hp.index(mir)+len(mir))
        
        (ss, mfe)=RNA.fold(hp)
        if mstart == 0:
            mirspos=get_s_rels(mstart+1,mstop+1,ss)
        else:
            mirspos=get_s_rels(mstart,mstop,ss)

        #Python indexing of mir position
        mirsspos=[(mirspos[0]-1),(mirspos[1]-1)]
        if mirsspos[0] > mirsspos[1]:
            flag=["mirStar not indexable"]
            mySeparator = ";"
            add_values_in_dict(mirna_dict,x,[mir.translate(str.maketrans("tT", "uU")),len(mir_one[x]),mstart,mstop,"NA","NA",mirsspos[0],mirsspos[1],hp.translate(str.maketrans("tT", "uU")),len(hp),"Fail",myseperator.join(flag),"NA","NA","NA","NA","NA","NA"])
        else:
            mirstar=hp[mirsspos[0]:mirsspos[1]]

            mirpos=[mstart,mstop]
            result = score(mir,hp,mirsspos,mirpos,ss)        
            mirstar=hp[mirsspos[0]:mirsspos[1]]

            if len(result[1]) == 0:
                flag = ["NA"]
            else:
                flag=list(result[1])
            
            if sum(result[0]) < 80:
                flag=result[1]
                add_values_in_dict(mirna_dict,x,[mir.translate(str.maketrans("tT", "uU")),len(mir_one[x]),mstart,mstop,str(mirstar.translate(str.maketrans("tT", "uU"))),len(mirstar),mirsspos[0],mirsspos[1],hp.translate(str.maketrans("tT", "uU")),len(hp),"Fail",''.join(str(e) for e in flag),result[2][2],result[2][3]])
            else:
                add_values_in_dict(mirna_dict,x,[mir.translate(str.maketrans("tT", "uU")),len(mir_one[x]),mstart,mstop,str(mirstar.translate(str.maketrans("tT", "uU"))),len(mirstar),mirsspos[0],mirsspos[1],hp.translate(str.maketrans("tT", "uU")),len(hp),"Pass",''.join(str(e) for e in flag),result[2][2],result[2][3]])

    else:
        failed[x]="miRNA not found in hairpin"

#Check hairpin length and multimap                   
print("Checking hairpin length and multimapping...")
for cand in list(mirna_dict.keys()):
    if cand in hp_dict:
        hp=hp_dict[cand].seq
        mir=mir_dict[cand].seq
        if (len(hp)<50):
            failed[cand] = "Hairpin is less than 50 basepairs"
            del mirna_dict[cand]
        else:
            if hp.count(mir)>1:
                failed[cand] = "miRNA multimaps to hairpin" 
                del mirna_dict[cand]
                   
#If all miRNAs fail at this point, quit.
if len(mirna_dict)<1:
    sys.exit("Error: no candidate miRNAs left to score.")

#If FASTQ files are provided, map to hairpins.
if args.fastq is not None:

##Create a list of all fastq files in provided directory.
    fastqs=glob.glob(args.fastq + '/*.fastq')
    if len(fastqs)<2:
        sys.exit("Error: miRScore requires at least two fastq files.")
    #Make output directory.
    subprocess.call(["mkdir","alignments"])

    align_fastqs(args,fastqs)
#If BAM files provided, convert to FASTQ then map to hairpins.
elif args.bamfile is not None:
    print("Converting BAM to FASTQ for mapping to hairpin...")
    bams2convert=glob.glob(args.bamfile + "/*.bam")
    if len(bams2convert)<2:
        sys.exit("Error: miRScore requires at least two libraries.")
    for file in bams2convert:
        cmd = "samtools bam2fq " + file + ' >' + args.bamfile + Path(file).stem + ".fastq"
        run(cmd)
    fastqs=glob.glob(args.bamfile + '*.fastq')
    subprocess.call(["mkdir","alignments"])
    align_fastqs(args,fastqs)

bamfiles=glob.glob('alignments/*.bam')

for bam in bamfiles:
    pysam.sort("-o", "alignments/" + Path(bam).stem + "_sorted.bam", bam)
    pysam.index("alignments/" + Path(bam).stem + "_sorted.bam")

                   
                   
mirna_counts={}
loci_counts={}
#Read counting
bamfiles=glob.glob('alignments/*sorted.bam')
if len(bamfiles)==0:
    msg = 'Requires two or more successfully mapped alignments. Check input read files to ensure they are trimmed and contain reads that map to hairpins.'
    sys.exit(msg)

#Count reads for each miRNA in each library                   
for bam in bamfiles:
    print("Counting reads in " + bam + "...")
    for x in tqdm.tqdm(mirna_dict,desc="Counting reads"):
        if "mirStar not indexable" not in mirna_dict[x][11]:
            if mirna_dict[x][2] !=0 and mirna_dict[x][6]!=0:
                mstart_indx=mirna_dict[x][2]-1
                mstop_indx=mirna_dict[x][3]+1
                mirstart_indx=mirna_dict[x][6]-1
                mirstop_indx=mirna_dict[x][7]+1
                mir=str(mirna_dict[x][0][1:-1])
                mirstar=mirna_dict[x][4][1:-1]
            else:
                mstart_indx=mirna_dict[x][2]
                mstop_indx=mirna_dict[x][3]+1
                mirstart_indx=mirna_dict[x][6]
                mirstop_indx=mirna_dict[x][7]+1
                mir=str(mirna_dict[x][0][1:-1])
                mirstar=mirna_dict[x][4][1:-1]

            #MIR COUNTS
            command=("samtools view " + bam + " "+ x+":" + str(mstart_indx) + "-"+str(mstop_indx) + "| cut -f10 | grep '" + mir.translate(str.maketrans("uU", "tT")) + "' | wc -l")
            p = Popen(command, shell=True, stdout=PIPE, stderr=STDOUT)
            output = p.stdout.read()
            splt = output.decode()
            count=splt.split()
            add_values_in_dict(mirna_counts,x,[count[0]])
            
            
            #MIRSTAR counts
            command=("samtools view " + bam + " "+ x+":" + str(mirstart_indx) + "-"+str(mirstop_indx) + "| cut -f10 | grep '" + mirstar.translate(str.maketrans("uU", "tT")) + "' | wc -l")
            p = Popen(command, shell=True, stdout=PIPE, stderr=STDOUT)
            output = p.stdout.read()
            splt = output.decode()
            count=splt.split()
            add_values_in_dict(mirna_counts,x,[count[0]])

            command=("samtools view " + bam + " "+ x+ "| wc -l")
            p = Popen(command, shell=True, stdout=PIPE, stderr=STDOUT)
            output = p.stdout.read()
            splt = output.decode()
            count=splt.split()
            add_values_in_dict(loci_counts,x,[int(count[0])])

#Check if reads are detected in two or more libraries for each miRNA.                   
print("Checking miRNA counts now...")
for x in tqdm.tqdm(mirna_counts):
    sleep(0.01)
    mircounts=[]
    mirscounts=[]
    y=int(len(bamfiles))
    mirstar_reads=(mirna_counts[x][1::y])
    mir_reads=(mirna_counts[x][::y])
    for c in mirstar_reads:
        mirscounts.append(int(c))
    for c in mir_reads:
        mircounts.append(int(c))
    
    mircount = 0
    for i in mir_reads:
        if int(i) > 0:
            mircount = mircount + 1
    
    mirstarCount=0
    for i in mirstar_reads:
        if int(i) > 0:
            mirstarCount = mirstarCount + 1

    if mirstarCount <1 or mircount <1:
        mirna_dict[x][10]="Fail"
        mirna_dict[x][11]+="Not present in 2 or more libraries"
        if sum(loci_counts[x]) != 0:
            precision="{:.2f}".format((100*(sum(mircounts)+sum(mirscounts))/sum(loci_counts[x])))
        else:
            precision= 0
        add_values_in_dict(mirna_dict,x,[sum(mircounts),sum(mirscounts),sum(loci_counts[x]),precision])

    else:
        precision=(100*((sum(mircounts)+sum(mirscounts))/sum(loci_counts[x])))
        if precision < 75:
            mirna_dict[x][10]="Fail"
            mirna_dict[x][11]+="Precision less than 75%"
            add_values_in_dict(mirna_dict,x,[sum(mircounts),sum(mirscounts),sum(loci_counts[x]),precision])

        else:
            add_values_in_dict(mirna_dict,x,[sum(mircounts),sum(mirscounts),sum(loci_counts[x]),precision])
                                    
                   
#Add miRNAs that failed to dictionary of all miRNAs.
for mirfail in failed:
        seq = str(hp_dict[mirfail].seq)
            #mature sequence
        mat = str(mir_one[mirfail])
        mstart=seq.index(mat)
        mstop=(seq.index(mat)+len(mat))

        (ss, mfe)=RNA.fold(seq)
        mirspos=get_s_rels(mstart,mstop,ss)
        #Python indexing of mir position
        mirsspos=[(mirspos[0]-1),(mirspos[1]-1)]
        mirstar=hp[mirsspos[0]:mirsspos[1]]
        add_values_in_dict(mirna_dict,mirfail,[mat,len(mat),mstart,mstop,mirstar,len(mirstar),mirsspos[0],mirsspos[1],seq,len(seq),"Fail",str(failed[mirfail]),"NA","NA","NA","NA","NA","NA","NA","NA"])

                   
#Create RNA plots using strucVis                  
subprocess.call(["mkdir","strucvis_plots"])

#Merge bamfiles for read depth of RNA plots.                    
cmd="samtools merge alignments/merged.bam alignments/*sorted.bam"
run(cmd)
print("Indexing merged bamfile...")
cmd="samtools index alignments/merged.bam"
run(cmd)

#Plot only miRNA that passed.
for x in tqdm.tqdm(mirna_dict,desc="Plotting RNA structures"):
    if "Fail" in mirna_dict[x][10]:
        pass
    else:
        hp_len=str(mirna_dict[x][9])
        cmd="strucVis -b alignments/merged.bam -g " + args.precursors + " -c "+ x + ":1-" + hp_len + " -s plus -p strucvis_plots/" +x+ ".ps -n " + x
        run(cmd)

#Write output file
from csv import writer
header=["name","mSeq"," mLen","mStart","mStop","msSeq","msLen","msStart",'msStop',"precSeq","precLen","result", "flags","mismatches","bulges",'mReads','msReads',"totReads","precision"]
with open("miRScore_results.csv", mode="w", newline='') as csv_out:
    csv_writer = writer(csv_out)
    csv_writer.writerow(header)
    for k, v in mirna_dict.items():
        csv_writer.writerow([k, *v])

                   
print("Summary")
print("____________________________________")
print("Number of submitted candidate miRNAs: " + str(len(mir_dict)))
res_pass = 0
for key in mirna_dict:
    if mirna_dict[key][10] == "Pass":
        res_pass = res_pass + 1
print("Total number of miRNAs identified with high confidence: " + str(res_pass) )
res_fail = 0
for key in mirna_dict:
    if mirna_dict[key][10] == "Fail":
        res_fail = res_fail + 1
print("Total number of Failed miRNAs: " + str(res_fail))
print('')
executionTime = (time.time() - startTime)
print('Time to run: ' + str(executionTime))
print('Run Completed!')
